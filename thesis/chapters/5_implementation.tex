\chapter{Implementation}

This chapter will present concrete implementations of Psnodig and its parts. As previously mentioned, Psnodig is really just an intermediate representation of a computer program. The tool is materialised through a parser and multiple writers, all written in Haskell. \\

First, we will roughly discuss Monads, which are essential to all of the implementations. Then, we will look at how the interpreter, parser and each of our writers are created. \\

\section{Psnodig}

In the previous chapter, we looked at Psnodig syntax from the point of its EBNF notation. \Cref{Psnodig's data types in Haskell.} shows the raw data types which define the tool's syntax. \\

\begin{lstlisting}[caption={Psnodig's data types in Haskell.}, captionpos=b, label={Psnodig's data types in Haskell.}]
data Program = Program [StructDecl] [Function] 
                       (Maybe FunctionCall)

data StructDecl = StructDecl String [Argument]

data Struct = Struct String [Expression]

data StructField = StructField Expression Expression

data Function = Function String [Argument] [Statement]

data FunctionCall = FunctionCall String [Expression]

data Argument = Argument String String

data Statement =
      Assignment AssignmentTarget AssignmentValue
    | Loop Expression [Statement]
    | If Expression [Statement] (Maybe Else)
    | ForEach String Expression [Statement]
    | For String Expression Expression [Statement]
    | CallStmt FunctionCall
    | Return Expression
    | HashStmt Statement
    | AnnotationStmt String [Statement]
    | Break
    | Continue

data AssignmentTarget =
      VariableTarget String
    | ListIndexTarget String [Expression]
    | StructFieldTarget StructField

data AssignmentValue =
      ExpressionValue Expression
    | StructValue Struct

data Else =
      ElseIf Expression [Statement] (Maybe Else)
    | Else [Statement]

data Expression =
      Constant Value
    | VariableExp String
    | BinaryExp Operator Expression Expression
    | ListIndex String [Expression]
    | CallExp FunctionCall
    | Not Expression
    | StructExpr Struct
    | StructFieldExp StructField

data Operator =
      Plus
    | Minus
    | Times
    | Division
    | LessThan
    | LessThanEqual
    | GreaterThan
    | GreaterThanEqual
    | Equal
    | NotEqual
    | And
    | Or
    | Modulo

data Value =
      Nil
    | Boolean Bool
    | Number Integer
    | Decimal Double
    | Text String
    | List [Expression]
    | HashSet (Set.Set Expression)
    | HashMap (Map.Map Expression Expression)
    | StructVal [(String, Value)]
\end{lstlisting}

\section{Monads}

First introduced in a programming context by Philip Wadler back in the 90's, monads allow us to structure computations within programs~\cite{originOfMonads, leifharaldMaster}. They are a fundamental pattern that harmonise the needs of imperative and functional programming. They preserve the benefits of functional purity, whilst elevating the expressiveness of our code. \\

Haskell is a purely functional programming language~\cite{whatIsHaskell}. In this paradigm, functions' output values are solely determined by their input values. \textit{Side effects} are operations that occur outside a function's scope, somehow affecting or depending on an external state. Monads are a way of keeping the immutable and predictible nature of our functions, whilst simultaneously working with the ``outside world''. \\

Monads play a vital role in all of our main implementations. For instance, the interpreter uses monads to modify a global state, and our TBP writer uses monads to read from an external environment. \\

We also utilise monads for more effective error handling, mainly in our interpreter. We use the \textbf{Maybe} monad, which returns either \texttt{Just value} or \texttt{Nothing}, and the \textbf{Either} monad, which returns either \texttt{Left value} or \texttt{Right value}. \\

\texttt{Maybe} is used for lookups, for instance when trying to access the value of a variable. Thus, we either return the value, or \texttt{Nothing}, if it is not already bound. \texttt{Either} is used when we expect one of two values, though the left side is often associated with an error. For instance, running a Psnodig program will yield either an error, or the state of the finished program. \\

The remaining implementations in this chapter will for the most part revolve around the monad we opted for.

\section{Interpreter}

\subsection{Monad}

The interpreter is built around our monad of choice, \textbf{StateT ExecutionState (ExceptT RuntimeError IO)}. It arguably looks a bit heavy, so let us break it down. The main point of our monad is \texttt{StateT}, whose signature is \texttt{StateT s m a}.\footnote{More documentation can be found at~\url{https://hackage.haskell.org/package/transformers-0.6.1.1/docs/Control-Monad-Trans-State-Lazy.html\#g:2}} As you can see, it takes three arguments: some state \texttt{s}, an inner monad \texttt{m}, and lastly \texttt{a}, the type of the result of applying the monad.

\subsubsection{ExecutionState}

The state we apply is \texttt{ExecutionState}, fleshed out in \Cref{psnodigInterpreterState}. It is a compound type with named fields, and closely resembles a struct in programming languages like Go and C. Applying \texttt{StateT} allows us to maintain and operate on this state throughout computations. \\

\begin{lstlisting}[caption={The Psnodig interpreter's state.}, captionpos=b, label={psnodigInterpreterState}]
type StructDecls = Map.Map String [String]
type FuncEnv = Map.Map String Function
type Scope = [[(String, Value)]]
type ScopeStack = [Scope]

data ExecutionState = ExecutionState
    { structDecls :: StructDecls
    , funcEnv     :: FuncEnv
    , scopeStack  :: ScopeStack
    , output      :: [String]
    }
\end{lstlisting}

It contains \texttt{structDecls}, which is a declaration of structs. This is a mapping from struct names to their corresponding fields. For instance, the value \texttt{StructDecl "Person" [Argument "name" "txt", Argument "age" "int"]} is saved as a mapping from \texttt{"Person"} to \texttt{["name", "age"]}. \\

We also have \texttt{funcEnv}, which is a declaration of functions. It is a mapping from function names to the corresponding function values. If we call a function, we can look it up, bind the arguments to temporary values, and run the statements within the function body. The use of \texttt{Map} was primarily chosen due to its O(log n) lookups,\footnote{The entire Map documentation can be found at \url{https://hackage.haskell.org/package/containers-0.4.0.0/docs/Data-Map.html}} which beats the O(n) lookups of its \texttt{List} counterpart.\footnote{The entire List documentation can be found at \url{https://hackage.haskell.org/package/base-4.19.1.0/docs/Data-List.html}} \\

The third value in our state is the \texttt{scopeStack}. This is a triple nested list of \texttt{(String, Value)} pairs. A pair of this type is a binding, so writing \texttt{x := 23} will create the binding \texttt{("x", Number 23)}. The initial scope list is intended to be the base level scope of a function. \\

The nesting accounts for loops and if-statements. Upon entering e.g. a while-loop, we push a new scope to the stack, and all variables created within this loop will die when we exit the loop. The last nesting introduced by \texttt{ScopeStack} accounts for functions. Each function has their own scope, much like any other programming language. \\

Lastly, our state takes care of \texttt{output}, which is a list of strings. This stores whatever we pass to the \texttt{print} function. If a program crashes, only the print-calls up until the crash will be presented in the terminal, which makes it a great tool for debugging. If a program runs uninterrupted, all print-calls will be presented in the terminal.

\subsubsection{ExceptT}

The inner monad that StateT operates over is \texttt{ExceptT RuntimeError IO}. This allows us to augment the \texttt{IO} monad with a value of type \texttt{RuntimeError}. The latter is several types of custom error messages, to locate the source of error easier. The entire list is shown in \Cref{psnodigErrorMsgs}. \\

\begin{lstlisting}[caption={All error messages to be encountered in Psnodig.}, captionpos=b, label={psnodigErrorMsgs}]
data RuntimeError =
      VariableNotFound String
    | FunctionNotFound String
    | StructNotFound String
    | ArithmeticError String
    | BadArgument String
    | WrongNumberOfArguments String
    | NoReturnError String
    | Error String
    | RuntimeErrorWithOutput [String] RuntimeError
    deriving (Show)
\end{lstlisting}

What this really means is that we have a computation that does IO (prints to the terminal). If we encounter an error condition, we do not proceed with further computations, and instead return the error, which is also displayed in the terminal. This is also what allows us to print errors, by joining the current print calls to \texttt{RuntimeErrorWithOutput}, and followingly displaying them to the terminal before the error message.

\subsection{Deviations from Psnodig Syntax}

Even though Psnodig's syntax opens up for it, the interpreter does not currently support Break- and Continue statements. This would require a significant refactoring of our monad, and potentially a larger refactoring of the entire interpreter. \\

\section{Gourmet}

There are two tools related to Gourmet: a parser and a writer.

\subsection{Parser}

We used the Haskell library Parsec to write the parser for Gourmet. Parsec is an industrial-strength parser library, being simple, safe, and well documented.\footnote{The entire Parsec documentation can be found at \url{https://hackage.haskell.org/package/parsec}} It is monadic parser combinator library, which roughly means that it combines multiple smaller parsers using monadic abstraction. This allows us to write a parser very succinctly, describing each rule in more or less natural language. \\

Parsec also lets us write our lexer and parser in one. The entire lexer is presented in \Cref{The Gourmet lexer.}, which takes up just 20 lines. It could have been presented with even fewer lines, but we have focused on readability instead of showboating. The lexer mainly defines the form of identifiers, comments and reserved names. \\

\begin{lstlisting}[caption={The Gourmet lexer.}, captionpos=b, label={The Gourmet lexer.}]
lexer :: Token.TokenParser ()
lexer = Token.makeTokenParser emptyDef {
    Token.identStart = letter,
    Token.identLetter = alphaNum <|> char '\'',
    Token.reservedOpNames =
        [ ":=", "+", "-", "*", "/", "<", ">", "=="
        , "!=", "{", "}", "(", ")", ">=", "<="
        , "[", "]", "&&", "||", "!", ",", ":", "#"
        , "@", "%", "."
        ],
    Token.reservedNames =
        [ "while", "if", "func", "true", "false"
        , "return", "else", "for", "break", "set"
        , "map", "not", "struct", "continue"
        ],
    Token.commentStart = "/*",
    Token.commentEnd = "*/",
    Token.commentLine = "//",
    Token.nestedComments = False
}
\end{lstlisting}

\Cref{parsingGourmet} shows the entry function, and how programs are parsed. We parse all struct declarations, function declarations, and potentially a function call, before the program returns the resulting AST in a Parser context. \texttt{Many} means 0 or more, and \texttt{optionMaybe} means 0 or 1. This also reveals that any text written after the function call is simply ignored. \\

\begin{lstlisting}[caption={Parsing Gourmet programs.}, captionpos=b, label={parsingGourmet}]
parseGourmet :: Parser Program
parseGourmet = do
    whiteSpace
    structs <- many parseStructDecl
    funcs <- many parseFunction
    functioncall <- optionMaybe parseFunctionCall
    return $\$$ Program structs funcs functioncall
\end{lstlisting}

We have opted for an applicative programming style when developing the parser, which means that we use applicative functors. The four central ones are \texttt{$<$\$$>$}, \texttt{$<$*$>$}, \texttt{*$>$}, and \texttt{$<$*}. An example where all are applied can be seen in \Cref{Parsing Gourmet function calls.}, where we parse function calls. Remember, the Psnodig FunctionCall data type is \texttt{FunctionCall String [Expression]}. \\

\texttt{$<$\$$>$} allows us to put everything on the right as arguments to \texttt{FunctionCall}. \texttt{$<$*} means that we parse both the left side and the right side, but only keep the left side. \texttt{*$>$} means the opposite. \texttt{$<$*$>$} means that we keep both. \\

\begin{lstlisting}[caption={Parsing Gourmet function calls.}, captionpos=b, label={Parsing Gourmet function calls.}]
parseFunctionCall :: Parser FunctionCall
parseFunctionCall =
    FunctionCall
        <$\$$> identifier
        <* reserved "("
        <*> parseExpr `sepBy` comma
        <* reserved ")"
\end{lstlisting}

\subsection{Writer}

Creating a writer when you already have a parser is manageable. In fact, the writer is more or less just a reverse engineering of the parser. The only potential difference between a Gourmet program we write, and the corresponding Gourmet program Psnodig can give us, is the formatting. \\

Since Psnodig does not take formatting into consideration, it has no way of knowing the combination of whitespace we used in our program. Therefore, we use the function in \Cref{helperFunc} to add indentation. This is used when entering new scopes in loops and if-statements, to add readability to our programs. Thus, in a way Psnodig works like a linter: By transpiling our Gourmet programs, we receive semantically identical programs, but with the intended amount of whitespace. \\

\begin{lstlisting}[caption={A function for adding indentation.}, captionpos=b, label={helperFunc}]
addIndents :: Int -> String
addIndents n = replicate n '\t'
\end{lstlisting}

The monad we opted for here is a simple \texttt{Writer String}. This allows computations to produce a String as the final result. We traverse the AST and use the \texttt{tell} function to write the corresponding Gourmet syntax. The final result is therefore just a combination of strings added together.

\section{Python Writer}

The Python writer works exactly like the Gourmet writer, with the exception of a few differences in syntax, like using colons over curly braces. Except for this, the monad is the same, as well as helper functions like the one presented in \Cref{helperFunc}.

\section{Pseudocode Writer}

The monad we opted for was similar to the one of the Gourmet writer. However, before we write our pseudocode, another program skims the AST and grabs some valuable information. This informations, like function names and whether or not there are return statements, is then stored in a tuple of sets. The first set contains function names, and the second set contains keywords. The TBP writer then uses this information to utilise Algorithm2e better. \\

The monad is \texttt{ReaderT Environment (Writer String)}. The last part is already covered in the previous section. However, we are now also working with \texttt{ReaderT Environment}. \texttt{ReaderT} adds the ability to read from a fixed environment. In our case, \texttt{Environment} is the set tuple that contains all the information collected from the AST.

\section{Flowchart Writer}

The monad we used for the IBP monad is very similar to the one of the TBP writer, but instead of using \texttt{ReaderT}, we opted for \texttt{StateT}, like with our interpreter. \Cref{The IBP monad's environment type} shows the Environment type in its entirety. \\

\begin{lstlisting}[caption={The IBP monad's environment type.}, captionpos=b, label={The IBP monad's environment type}]
data Environment = Environment
    { edges :: [(Int, String)]
    , lastId :: Int
    , coreId :: [Int]
    , activeBranches :: [String]
    }    
\end{lstlisting}

Since we update node ids every time we enter a new statement, it can be challenging to keep track of which nodes should correspond to which statements. Because we wish to write out all the edges \textit{after} writing out all the nodes, we have decided to save them in the \textbf{edges} data type. The corresponding integer will be the id of the sender node. This lets us sort the list and write all edges after we have written our nodes. \\

All nodes should have a unique id to make them referenceable later on, and to know which ids we have already generated, we keep a global \textbf{lastId}. Also, when working with e.g. \texttt{while} statements, we need to know which node we have to point back to. This is what we use \textbf{coreId} for. It is a list, in the case of nested special statements, so that we do not lose the original core id before we reference it. \\

\forsup{Ordet jeg tenker på er noe som ``outgoing node'' istedenfor ``sender'', men sliter med å plassere det.}

Lastly, we use \textbf{activeBranches} to deal with branches of if statements. As mentioned in Section 4.something, the last statement in an \texttt{If} must point to the next statement outside of the current \texttt{If}, as long as it is not a return statement. We populate this list with the id of all of these last statements (converted to strings, as we do not do arithmetic with them and they have to be converted at some point anyway). Later, after having processed the If statement, we use the ids to populate the \textbf{edges} list, pointing to the current id.

\section{Testing}

To feel more assured that the implementation correctly leads the design, we have adopted unit tests for all the tools that make up Psnodig. This includes the parser, all four writers, as well as the interpreter working on the internal representation of Psnodig. \\

Unit tests do well at isolating parts of our code into so-called \textbf{units}, and comparing them with expected results~\cite{whatIsUnitTesting}. We have opted for HUnit, a unit testing framework specifically designed for Haskell. HUnit lets us easily create, name and execute tests, with the framework checking the results automatically~\cite{hunit}. \\

By testing Psnodig, we are given a better insight into which parts work. We have kept the tests similar for each part, to be more certain that it is consistent. The tests makes the tool more robust as a whole. When adding a new parser or writer to Psnodig, we can add similar tests to make sure that they are compatible.

\subsection{Gourmet parser}

Since we only have one parser, it is important to know that it works as intended. Our goal is to see that we can successfully parse programs from Gourmet source code to a Psnodig AST. We have carried out tests from small values, like numbers and boolen values, to fully fledged programs.\footnote{The Gourmet parser test suite can be accessed here: \url{https://github.com/sergiosja/Master/blob/master/psnodig/test/parsers/Gourmet.hs}.} \\

To make sure the smallest building blocks were functioning properly, we tested all of Psnodig's \textbf{values}. This includes small and big numbers, decimals and booleans. We have also tested the compound values lists, hashsets and hashmaps, both empty and populated. \\

We have tested all types of \textbf{declarations}, that is program declaration (describing a function's input and output - tailored for the pseudocode writer), struct declarations and function declarations. \\

Psnodig's statements are essential to programs, so we tested all of them. This includes all kinds of assignment, while- and for-loops, function calls, and also Psnodig's famous hash- and annotation-statements. \\

We have also tested all of Psnodig's \textbf{expressions}, which are essential to statements. This includes function calls, accessing on list indexes, constants, as well as negated expressions, and more. \\

And lastly, we have tested entire Psnodig programs. Both completely empty programs, but also ones containing all types of declarations and a triggering function call. \\

Passing all these tests make us trust our implementation more. We know that our parser is able to parse both small parts, but also entire programs into a well-defined Psnodig AST.

\subsection{Writers}

Now that we are certain that we can convert Gourmet programs to Psnodig ASTs, we are also interested to know that we can convert them further. We have created four test suites, one for each of our writers. They all look very similar, and purposely test the same AST tokens. \\

Another useful aspect of having unit tests for the writers, is to show how they coincide with the built-in functions of Psnodig.

\subsubsection{Gourmet}

An interesting aspect of the transpiler is to see if we can convert Gourmet programs ``back to themselves''. We tested the exact same attributes for the writer as we did for the parser, but reversed in the sense that we went from an AST to a program. \\

As previously mentioned, Psnodig does not take whitespace into consideration, so a program like \texttt{if x \{ return y\}} is transpiled to \texttt{if x \{\textbackslash n\textbackslash t return y\textbackslash n\}}. Other than that, all values, declarations, expressions, statements and programs were losslessly transpiled.\footnote{The Gourmet writer test suite can be accessed here: \url{https://github.com/sergiosja/Master/blob/master/psnodig/test/writers/Gourmet.hs}.}

\subsubsection{Python}

Python is on a similar abstraction level to Gourmet, but still has a few differences. For instance, the conversion from structs to classes, and how we deal with hash- and annotation statements. Through unit tests we were able to make sure that the results are as intended. \\

We tested the same parts as we did with the Gourmet parser.\footnote{The Python writer test suite can be accessed here: \url{https://github.com/sergiosja/Master/blob/master/psnodig/test/writers/Python.hs}.}

\subsubsection{Pseudocode}

We also have test the conversion to TBP. When looking at smaller ASTs, the difference in TBP and Gourmet/Python is not that big. However, we lean heavily on the Algorithm2e when it comes to statements, and the test show that we utilise the package well. The tests also help us see that we balance the dollar signs (for math mode) well. \\

We have tested the same ASTs as before, except for the ones containing struct declarations, as they are not converted to TBP anyway.\footnote{The Pseudocode writer test suite can be accessed here: \url{https://github.com/sergiosja/Master/blob/master/psnodig/test/writers/Pseudocode.hs}}

\subsubsection{Flowcharts}

\forsup{Not done yet}

\subsection{Interpreter}

\forsup{Not done yet}