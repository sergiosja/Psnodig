\chapter{Background} % nothing of mine
\begin{itemize}
    \item Previous work within the scope of the thesis
    \item Relevant related work like Pandoc and Derw
    \item Important definitions
\end{itemize}

utrolig mye bra her: https://www.dei.unipd.it/\~emg/downloads/SIMPAR08-WorkshopProceedings/TeachingWithRobotics/karatrantou.pdf!! veldig mange bra kilder \hfill \\

This chapter will cover concepts that one should be familiar with in order to fully understand the rest of this thesis. We start by defining pseudocode to avoid confusion further down the line, as well as discussing transpiling, why Haskell is a good tool for the job, and how other transpilers work.

\section{Pseudocode}

Pseudocode is a technique for describing computer programs in a more abstract way than programming languages allow, ignoring specific syntax and keywords. This can make programs easier to understand for both non-programmers and programmers alike, when dealing with new situations \cite{LinfoAlgorithmsIntro2007}. \hfill \\

Since it does not follow any partifular syntax rules, pseudocode is also not executable. The whole point is that it is a way of \textit{presenting} code, rather than actually being code (rewrite needed) [kilde]. As such, pseudocode is an abstract concept, and can technically be anything, as long as it aims to aid others in understanding what a particular piece of code does [kilde]. \hfill \\

Now, since pseudocode has many faces, we must define what we percieve pseudocode to be in the context of this thesis, and what exactly we mean when we refer to ``pseudocode'' in later parts of the thesis. To avoid further confusion, we make a distinction between two particular types of pseudocode: text based and image based.

\subsection{Text based pseudocode}

Black n white stuff \hfill \\

Paper on Latex lib for creating TBP: https://mirror.unpad.ac.id/ctan/macros/latex2e/contrib/pseudocode/pseudocode.pdf \\

Paper on pseudocode (natural language) from Python, with SMT: https://mirror.unpad.ac.id/ctan/macros/latex2e/contrib/pseudocode/pseudocode.pdf \\

Another one on pseudocode (natural language) from Python, but with deep learning: https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8587282\&casa\_token=3-3FqPeozQMAAAAA:9\_dn28HbC2kXbImWk-seSPXFgO-XfpR2IHqAKdx9f5SwOnbEhqVvdR-wznMvL7ToRqGJAoV8Mkw\&tag=1 \\

Impact of pseudocode: https://iopscience.iop.org/article/10.1088/1757-899X/835/1/012044/pdf

\subsection{Image based pseudocode}

Not all programming languages share the same execution flow. For istance, in VHDL all processes are executed simultaneously\footnote{https://www.people.vcu.edu/~rhklenke/tutorials/vhdl/modules/m12\_23/sld008.htm}, whilst in Maude rules are applied in an arbitrary order [kilde]. Some, on the other hand, like Python, will execute their programs line for line. This means that we can follow the execution flow simply by looking at the order functions are called and the order of statements within those functions. \hfill \\

This way of executing a program opens up for the possibility of flowcharts, which still includes text, but also complements it with boxes, arrows and perhaps pretty colours. When code stretches over enough lines, it all starts looking similar and confusing [kilde]. Flowcharts, on the other hand, does a good job of isolating each statement, and potentially gives more of a birds eye view perspective of the code [kilde?]. \hfill \\

Bra språk for å snakke om flowcharts: https://www.researchgate.net/publication/234805404\_Flowchart\_techniques\_for\_structured\_programming \\

Flowchart editor: https://www.researchgate.net/publication/234809385\_RAPTOR\_introducing\_programming\_to\_non-majors\_with\_flowcharts \\

Flowchart editor I think: https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4141379\&casa\_token=GEeSdBwgDfQAAAAA:6BaytVq0aANwj59lq2bHpcyMhV0enyZpOCuz93kEV\_tMaiQPHVY1OpwXO\_Gg1oDtxoKmfvXad4s \\

Generating code FROM flowcharts: https://www.scirp.org/html/7515.html \\

Impact of flowcharts: https://iopscience.iop.org/article/10.1088/1757-899X/835/1/012044/pdf

\section{Transpiling}
We have a program, we transform that into an intermediate representation, and from that intermediate representation we can get an entirely new representation. \hfill \\

An alternative to transpiling is the well-known phenomenon of \textit{compiling}. The difference is that we do not stay on the same abstraction level, but rather we make it much more specific. An example of this is compiling a Java file to bytecode. To humans, the bytecode reads like the most foreign language, though the JVM understands it perfectly, and is able to execute it. \hfill \\

\subsection{Generators}
One technique of utilising parsers and writers is to apply generators. A generator is basically a stand-alone parser or writer. A parser generator, in the context of Psnodig, would translate an example program to an AST, whilst a writer generator would translate an AST to a program. \hfill \\

An example of this is the programming language Derw\footnote{https://github.com/eeue56/derw}, an ML language mainly inspired by Elm. By utilising generators, it has multiple writers, among others bytecode, JavaScript, and even English. \hfill \\

Another example is Pandoc\footnote{https://github.com/jgm/pandoc}, which works with markdown languages. It has a ``core language'' which all parsers and writers must oblige to, and looks like this

\begin{verbatim}
    Plain [Inline]
    Para [Inline]
    LineBlock [[Inline]]
    CodeBlock Attr String
    RawBlock Format String
    BlockQuote [Block]
    OrderedList ListAttributes [[Block]]
    BulletList [[Block]]
    DefinitionList [([Inline], [[Block]])]
    Header Int Attr [Inline]
    HorizontalRule
    Table [Inline] [Alignment] [Double] [TableCell] [[TableCell]]
    Div Attr [Block]
    Null
\end{verbatim}

Every inputlanguage must be able to parse to (at least) these data types, and every writer must be able to work with these data types. \hfill \\

- Give example with e.g. HTML and MD for one of the data types?

\subsection{Haskell's strengths}
As previously mentioned, we opted for the Haskell programming language when implementing Psnodig. There are several reasons as to why, but the primary one is that it is widely perceived as a fitting tool when working with programming languages, and particularly when working with interpreters\footnote{https://github.com/Gabriella439/post-rfc/blob/main/sotu.md\#compilers}. At the end of the day, programming languages are just tools, and we believe this is the best one for this particular job. \hfill \\

With Haskell, it is straightforward to create your own \textbf{data types}, which are then used to model abstract syntax trees (ASTs). For instance, we can create our own calculator language in just a few lines of code:

\begin{verbatim}
    data Program = Program Expression

    data Expression =
          CompoundExpression Integer Operator Expression
        | IntExpression Integer

    data Operator =
          Plus
        | Minus
        | Times
        | Division
\end{verbatim}

From this, we can construct the following AST:

\begin{verbatim}
    Program (CompoundExpression 1 Plus
                (CompoundExpression 2 Minus
                    (IntExpression 3))
\end{verbatim}

As you can also see, we could create much bigger calculations than this, and if we wish to include extra operators, like for instance exponents in the future, we simply add a \texttt{| Exponent} to the Operator data type. \hfill \\

Another benefit of using Haskell, is that its strong type system opens for clean and efficient pattern matching. This is very useful, both when writing the interpreter, but also when adding new, potential readers. For example, if we wish to transpile the above AST to text, we could start with writing a function to convert the operators:

\begin{lstlisting}[caption={Haskell example to convert data type to string}, captionpos=b]
    f :: Operator -> String
    f (Operator Plus)     = " + "
    f (Operator Minus)    = " - "
    f (Operator Times)    = " / "
    f (Operator Division) = " * "
\end{lstlisting}

The function \textbf{f} takes something of type \textbf{Operator} as input, and returns something of type \textbf{String}. It will pattern match on the input, and return a correspondng value, making it bijective. We could add case of \texttt{f \_ = ""}, which would return the empty string for any other kind of operator, though this would be redundant as we have not defined any other type of operator anyway. \hfill \\

Lastly, we can utilise the QuickCheck\footnote{https://hackage.haskell.org/package/QuickCheck}, which is a testing library suited for automatic property-based testing in Haskell. With this we can prove different properties of our tool \cite{DBLP:conf/icfp/ClaessenH00}, and perhaps also of other (primarily) parsers and (maybe) writers, given that they have to pass through Haskell ADTs anyway.